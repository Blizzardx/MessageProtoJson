package tool

import (
	"github.com/Blizzardx/MessageProtoJson/common"
	"github.com/Blizzardx/MessageProtoJson/define"
	"strconv"
)

const codeTemplate_GoEnum = `

type {{.EnumName}} int32

const (
{{range .EnumElemList}}
	{{.EnumName}}_{{.EnumElemName}} {{.EnumName}} = {{.EnumElemValue}}
{{end}}
)


`
const codeTemplate_GoClass = `

type {{.ClassName}} struct {
{{range .Field}}
	{{.Name}} {{.Type}}
{{end}}
}

`
const codeTemplate_Go = `// Generated by gen-tool
// DO NOT EDIT!
package {{.PackageName}}

{{range $_, $v := .EnumList}}
import"{{$v}}"
{{end}}
{{range $_, $v := .ClassList}}
import"{{$v}}"
{{end}}

`

type ExportHandler_GoInfo struct {
	PackageName string
	EnumList    []string
	ClassList   []string
}
type ExportHandler_GoEnumInfo struct {
	EnumName     string
	EnumElemList []*ExportHandler_GoEnumElementInfo
}
type ExportHandler_GoEnumElementInfo struct {
	EnumElemName  string
	EnumElemValue string
}
type ExportHandler_GoClassInfo struct {
	ClassName string
	Field     []*ExportHandler_GoClassElementInfo
}
type ExportHandler_GoClassElementInfo struct {
	Name string
	Type string
}
type ExportHandler_Go struct {
}

func (handler *ExportHandler_Go) DoExportProtoFileOnTarget(fileName string, provisionParserInfo *define.MessageProvisionParserInfo, exportPath string) error {
	filePath := exportPath + fileName + ".go"

	enumList, err := handler.genEnumContent(provisionParserInfo)
	if nil != err {
		return err
	}
	classList, err := handler.genClassContent(provisionParserInfo)
	if nil != err {
		return err
	}
	template := &ExportHandler_GoInfo{
		PackageName: provisionParserInfo.PackageName,
		EnumList:    enumList,
		ClassList:   classList,
	}
	content, err := generateCode(codeTemplate_Go, template, true)
	if nil != err {
		return err
	}

	err = common.WriteFileByName(filePath, []byte(content))
	return nil
}
func (self *ExportHandler_Go) genEnumContent(provisionParserInfo *define.MessageProvisionParserInfo) ([]string, error) {
	var result []string
	for _, enumProvision := range provisionParserInfo.EnumList {
		template := &ExportHandler_GoEnumInfo{EnumName: enumProvision.Name}
		for _, enumFiledInfo := range enumProvision.EnumInfo {
			enumValue := strconv.Itoa(enumFiledInfo.Value)
			template.EnumElemList = append(template.EnumElemList, &ExportHandler_GoEnumElementInfo{EnumElemName: enumFiledInfo.Name, EnumElemValue: enumValue})
		}
		content, err := generateCode(codeTemplate_GoEnum, template, false)
		if nil != err {
			return nil, err
		}
		result = append(result, content)
	}
	return result, nil
}
func (self *ExportHandler_Go) genClassContent(provisionParserInfo *define.MessageProvisionParserInfo) ([]string, error) {
	var result []string
	for _, classProvision := range provisionParserInfo.ClassList {
		template := &ExportHandler_GoClassInfo{ClassName: classProvision.Name}
		for _, classFiledInfo := range classProvision.FieldInfo {
			template.Field = append(template.Field, &ExportHandler_GoClassElementInfo{
				Name: classFiledInfo.Name,
				Type: self.getFieldType(classFiledInfo.Type, classFiledInfo.IsList)})
		}
		content, err := generateCode(codeTemplate_GoClass, template, false)
		if nil != err {
			return nil, err
		}
		result = append(result, content)
	}
	return result, nil

}
func (self *ExportHandler_Go) convertToSelfType(fieldType string) string {
	switch fieldType {
	case "int32":
		return "int32"
	case "int64":
		return "int64"
	case "float32":
		return "float32"
	case "float64":
		return "float64"
	case "bool":
		return "bool"
	case "string":
		return "string"
	default:
		return ""
	}
}
func (handler *ExportHandler_Go) getFieldType(fieldType string, isList bool) string {
	typeName := handler.convertToSelfType(fieldType)
	if isList {
		if typeName == "" {
			return "[]*" + fieldType
		}
		return "[]" + typeName
	}
	if typeName == "" {
		return fieldType
	}
	return typeName
}
